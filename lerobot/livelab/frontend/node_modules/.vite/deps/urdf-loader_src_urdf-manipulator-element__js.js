import {
  ColladaLoader
} from "./chunk-HFCYGSXX.js";
import {
  STLLoader
} from "./chunk-TUUE44ZB.js";
import {
  Box3,
  BoxGeometry,
  Controls,
  CylinderGeometry,
  DefaultLoadingManager,
  DirectionalLight,
  DoubleSide,
  Euler,
  HemisphereLight,
  LoaderUtils,
  LoadingManager,
  MOUSE,
  MathUtils,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshPhongMaterial,
  Object3D,
  PCFSoftShadowMap,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  Quaternion,
  Ray,
  Raycaster,
  SRGBColorSpace,
  Scene,
  ShadowMaterial,
  Sphere,
  SphereGeometry,
  Spherical,
  TOUCH,
  TextureLoader,
  Vector2,
  Vector3,
  WebGLRenderer
} from "./chunk-HCLXY2YZ.js";
import "./chunk-RDKGUBC5.js";

// node_modules/three/examples/jsm/controls/OrbitControls.js
var _changeEvent = { type: "change" };
var _startEvent = { type: "start" };
var _endEvent = { type: "end" };
var _ray = new Ray();
var _plane = new Plane();
var _TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);
var _v = new Vector3();
var _twoPI = 2 * Math.PI;
var _STATE = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
};
var _EPS = 1e-6;
var OrbitControls = class extends Controls {
  /**
   * Constructs a new controls instance.
   *
   * @param {Object3D} object - The object that is managed by the controls.
   * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
   */
  constructor(object, domElement = null) {
    super(object, domElement);
    this.state = _STATE.NONE;
    this.target = new Vector3();
    this.cursor = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minTargetRadius = 0;
    this.maxTargetRadius = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.keyRotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.zoomToCursor = false;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this._lastPosition = new Vector3();
    this._lastQuaternion = new Quaternion();
    this._lastTargetPosition = new Vector3();
    this._quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
    this._quatInverse = this._quat.clone().invert();
    this._spherical = new Spherical();
    this._sphericalDelta = new Spherical();
    this._scale = 1;
    this._panOffset = new Vector3();
    this._rotateStart = new Vector2();
    this._rotateEnd = new Vector2();
    this._rotateDelta = new Vector2();
    this._panStart = new Vector2();
    this._panEnd = new Vector2();
    this._panDelta = new Vector2();
    this._dollyStart = new Vector2();
    this._dollyEnd = new Vector2();
    this._dollyDelta = new Vector2();
    this._dollyDirection = new Vector3();
    this._mouse = new Vector2();
    this._performCursorZoom = false;
    this._pointers = [];
    this._pointerPositions = {};
    this._controlActive = false;
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    this._onContextMenu = onContextMenu.bind(this);
    this._onMouseWheel = onMouseWheel.bind(this);
    this._onKeyDown = onKeyDown.bind(this);
    this._onTouchStart = onTouchStart.bind(this);
    this._onTouchMove = onTouchMove.bind(this);
    this._onMouseDown = onMouseDown.bind(this);
    this._onMouseMove = onMouseMove.bind(this);
    this._interceptControlDown = interceptControlDown.bind(this);
    this._interceptControlUp = interceptControlUp.bind(this);
    if (this.domElement !== null) {
      this.connect(this.domElement);
    }
    this.update();
  }
  connect(element) {
    super.connect(element);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointercancel", this._onPointerUp);
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
    this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: false });
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keydown", this._interceptControlDown, { passive: true, capture: true });
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.removeEventListener("pointercancel", this._onPointerUp);
    this.domElement.removeEventListener("wheel", this._onMouseWheel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
    this.stopListenToKeyEvents();
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keydown", this._interceptControlDown, { capture: true });
    this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  /**
   * Get the current vertical rotation, in radians.
   *
   * @return {number} The current vertical rotation, in radians.
   */
  getPolarAngle() {
    return this._spherical.phi;
  }
  /**
   * Get the current horizontal rotation, in radians.
   *
   * @return {number} The current horizontal rotation, in radians.
   */
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  /**
   * Returns the distance from the camera to the target.
   *
   * @return {number} The distance from the camera to the target.
   */
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  /**
   * Adds key event listeners to the given DOM element.
   * `window` is a recommended argument for using this method.
   *
   * @param {HTMLDOMElement} domElement - The DOM element
   */
  listenToKeyEvents(domElement) {
    domElement.addEventListener("keydown", this._onKeyDown);
    this._domElementKeyEvents = domElement;
  }
  /**
   * Removes the key event listener previously defined with `listenToKeyEvents()`.
   */
  stopListenToKeyEvents() {
    if (this._domElementKeyEvents !== null) {
      this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown);
      this._domElementKeyEvents = null;
    }
  }
  /**
   * Save the current state of the controls. This can later be recovered with `reset()`.
   */
  saveState() {
    this.target0.copy(this.target);
    this.position0.copy(this.object.position);
    this.zoom0 = this.object.zoom;
  }
  /**
   * Reset the controls to their state from either the last time the `saveState()`
   * was called, or the initial state.
   */
  reset() {
    this.target.copy(this.target0);
    this.object.position.copy(this.position0);
    this.object.zoom = this.zoom0;
    this.object.updateProjectionMatrix();
    this.dispatchEvent(_changeEvent);
    this.update();
    this.state = _STATE.NONE;
  }
  update(deltaTime = null) {
    const position = this.object.position;
    _v.copy(position).sub(this.target);
    _v.applyQuaternion(this._quat);
    this._spherical.setFromVector3(_v);
    if (this.autoRotate && this.state === _STATE.NONE) {
      this._rotateLeft(this._getAutoRotationAngle(deltaTime));
    }
    if (this.enableDamping) {
      this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;
      this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;
    } else {
      this._spherical.theta += this._sphericalDelta.theta;
      this._spherical.phi += this._sphericalDelta.phi;
    }
    let min = this.minAzimuthAngle;
    let max = this.maxAzimuthAngle;
    if (isFinite(min) && isFinite(max)) {
      if (min < -Math.PI) min += _twoPI;
      else if (min > Math.PI) min -= _twoPI;
      if (max < -Math.PI) max += _twoPI;
      else if (max > Math.PI) max -= _twoPI;
      if (min <= max) {
        this._spherical.theta = Math.max(min, Math.min(max, this._spherical.theta));
      } else {
        this._spherical.theta = this._spherical.theta > (min + max) / 2 ? Math.max(min, this._spherical.theta) : Math.min(max, this._spherical.theta);
      }
    }
    this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi));
    this._spherical.makeSafe();
    if (this.enableDamping === true) {
      this.target.addScaledVector(this._panOffset, this.dampingFactor);
    } else {
      this.target.add(this._panOffset);
    }
    this.target.sub(this.cursor);
    this.target.clampLength(this.minTargetRadius, this.maxTargetRadius);
    this.target.add(this.cursor);
    let zoomChanged = false;
    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) {
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    } else {
      const prevRadius = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale);
      zoomChanged = prevRadius != this._spherical.radius;
    }
    _v.setFromSpherical(this._spherical);
    _v.applyQuaternion(this._quatInverse);
    position.copy(this.target).add(_v);
    this.object.lookAt(this.target);
    if (this.enableDamping === true) {
      this._sphericalDelta.theta *= 1 - this.dampingFactor;
      this._sphericalDelta.phi *= 1 - this.dampingFactor;
      this._panOffset.multiplyScalar(1 - this.dampingFactor);
    } else {
      this._sphericalDelta.set(0, 0, 0);
      this._panOffset.set(0, 0, 0);
    }
    if (this.zoomToCursor && this._performCursorZoom) {
      let newRadius = null;
      if (this.object.isPerspectiveCamera) {
        const prevRadius = _v.length();
        newRadius = this._clampDistance(prevRadius * this._scale);
        const radiusDelta = prevRadius - newRadius;
        this.object.position.addScaledVector(this._dollyDirection, radiusDelta);
        this.object.updateMatrixWorld();
        zoomChanged = !!radiusDelta;
      } else if (this.object.isOrthographicCamera) {
        const mouseBefore = new Vector3(this._mouse.x, this._mouse.y, 0);
        mouseBefore.unproject(this.object);
        const prevZoom = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
        this.object.updateProjectionMatrix();
        zoomChanged = prevZoom !== this.object.zoom;
        const mouseAfter = new Vector3(this._mouse.x, this._mouse.y, 0);
        mouseAfter.unproject(this.object);
        this.object.position.sub(mouseAfter).add(mouseBefore);
        this.object.updateMatrixWorld();
        newRadius = _v.length();
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.");
        this.zoomToCursor = false;
      }
      if (newRadius !== null) {
        if (this.screenSpacePanning) {
          this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(newRadius).add(this.object.position);
        } else {
          _ray.origin.copy(this.object.position);
          _ray.direction.set(0, 0, -1).transformDirection(this.object.matrix);
          if (Math.abs(this.object.up.dot(_ray.direction)) < _TILT_LIMIT) {
            this.object.lookAt(this.target);
          } else {
            _plane.setFromNormalAndCoplanarPoint(this.object.up, this.target);
            _ray.intersectPlane(_plane, this.target);
          }
        }
      }
    } else if (this.object.isOrthographicCamera) {
      const prevZoom = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
      if (prevZoom !== this.object.zoom) {
        this.object.updateProjectionMatrix();
        zoomChanged = true;
      }
    }
    this._scale = 1;
    this._performCursorZoom = false;
    if (zoomChanged || this._lastPosition.distanceToSquared(this.object.position) > _EPS || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > _EPS || this._lastTargetPosition.distanceToSquared(this.target) > _EPS) {
      this.dispatchEvent(_changeEvent);
      this._lastPosition.copy(this.object.position);
      this._lastQuaternion.copy(this.object.quaternion);
      this._lastTargetPosition.copy(this.target);
      return true;
    }
    return false;
  }
  _getAutoRotationAngle(deltaTime) {
    if (deltaTime !== null) {
      return _twoPI / 60 * this.autoRotateSpeed * deltaTime;
    } else {
      return _twoPI / 60 / 60 * this.autoRotateSpeed;
    }
  }
  _getZoomScale(delta) {
    const normalizedDelta = Math.abs(delta * 0.01);
    return Math.pow(0.95, this.zoomSpeed * normalizedDelta);
  }
  _rotateLeft(angle) {
    this._sphericalDelta.theta -= angle;
  }
  _rotateUp(angle) {
    this._sphericalDelta.phi -= angle;
  }
  _panLeft(distance, objectMatrix) {
    _v.setFromMatrixColumn(objectMatrix, 0);
    _v.multiplyScalar(-distance);
    this._panOffset.add(_v);
  }
  _panUp(distance, objectMatrix) {
    if (this.screenSpacePanning === true) {
      _v.setFromMatrixColumn(objectMatrix, 1);
    } else {
      _v.setFromMatrixColumn(objectMatrix, 0);
      _v.crossVectors(this.object.up, _v);
    }
    _v.multiplyScalar(distance);
    this._panOffset.add(_v);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(deltaX, deltaY) {
    const element = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const position = this.object.position;
      _v.copy(position).sub(this.target);
      let targetDistance = _v.length();
      targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180);
      this._panLeft(2 * deltaX * targetDistance / element.clientHeight, this.object.matrix);
      this._panUp(2 * deltaY * targetDistance / element.clientHeight, this.object.matrix);
    } else if (this.object.isOrthographicCamera) {
      this._panLeft(deltaX * (this.object.right - this.object.left) / this.object.zoom / element.clientWidth, this.object.matrix);
      this._panUp(deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element.clientHeight, this.object.matrix);
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
      this.enablePan = false;
    }
  }
  _dollyOut(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale /= dollyScale;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      this.enableZoom = false;
    }
  }
  _dollyIn(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale *= dollyScale;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      this.enableZoom = false;
    }
  }
  _updateZoomParameters(x, y) {
    if (!this.zoomToCursor) {
      return;
    }
    this._performCursorZoom = true;
    const rect = this.domElement.getBoundingClientRect();
    const dx = x - rect.left;
    const dy = y - rect.top;
    const w = rect.width;
    const h = rect.height;
    this._mouse.x = dx / w * 2 - 1;
    this._mouse.y = -(dy / h) * 2 + 1;
    this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(dist) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, dist));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(event) {
    this._rotateStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownDolly(event) {
    this._updateZoomParameters(event.clientX, event.clientX);
    this._dollyStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownPan(event) {
    this._panStart.set(event.clientX, event.clientY);
  }
  _handleMouseMoveRotate(event) {
    this._rotateEnd.set(event.clientX, event.clientY);
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const element = this.domElement;
    this._rotateLeft(_twoPI * this._rotateDelta.x / element.clientHeight);
    this._rotateUp(_twoPI * this._rotateDelta.y / element.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
    this.update();
  }
  _handleMouseMoveDolly(event) {
    this._dollyEnd.set(event.clientX, event.clientY);
    this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);
    if (this._dollyDelta.y > 0) {
      this._dollyOut(this._getZoomScale(this._dollyDelta.y));
    } else if (this._dollyDelta.y < 0) {
      this._dollyIn(this._getZoomScale(this._dollyDelta.y));
    }
    this._dollyStart.copy(this._dollyEnd);
    this.update();
  }
  _handleMouseMovePan(event) {
    this._panEnd.set(event.clientX, event.clientY);
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
    this.update();
  }
  _handleMouseWheel(event) {
    this._updateZoomParameters(event.clientX, event.clientY);
    if (event.deltaY < 0) {
      this._dollyIn(this._getZoomScale(event.deltaY));
    } else if (event.deltaY > 0) {
      this._dollyOut(this._getZoomScale(event.deltaY));
    }
    this.update();
  }
  _handleKeyDown(event) {
    let needsUpdate = false;
    switch (event.code) {
      case this.keys.UP:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateUp(_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(0, this.keyPanSpeed);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.BOTTOM:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateUp(-_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(0, -this.keyPanSpeed);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.LEFT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateLeft(_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(this.keyPanSpeed, 0);
          }
        }
        needsUpdate = true;
        break;
      case this.keys.RIGHT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (this.enableRotate) {
            this._rotateLeft(-_twoPI * this.keyRotateSpeed / this.domElement.clientHeight);
          }
        } else {
          if (this.enablePan) {
            this._pan(-this.keyPanSpeed, 0);
          }
        }
        needsUpdate = true;
        break;
    }
    if (needsUpdate) {
      event.preventDefault();
      this.update();
    }
  }
  _handleTouchStartRotate(event) {
    if (this._pointers.length === 1) {
      this._rotateStart.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._rotateStart.set(x, y);
    }
  }
  _handleTouchStartPan(event) {
    if (this._pointers.length === 1) {
      this._panStart.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._panStart.set(x, y);
    }
  }
  _handleTouchStartDolly(event) {
    const position = this._getSecondPointerPosition(event);
    const dx = event.pageX - position.x;
    const dy = event.pageY - position.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    this._dollyStart.set(0, distance);
  }
  _handleTouchStartDollyPan(event) {
    if (this.enableZoom) this._handleTouchStartDolly(event);
    if (this.enablePan) this._handleTouchStartPan(event);
  }
  _handleTouchStartDollyRotate(event) {
    if (this.enableZoom) this._handleTouchStartDolly(event);
    if (this.enableRotate) this._handleTouchStartRotate(event);
  }
  _handleTouchMoveRotate(event) {
    if (this._pointers.length == 1) {
      this._rotateEnd.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._rotateEnd.set(x, y);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const element = this.domElement;
    this._rotateLeft(_twoPI * this._rotateDelta.x / element.clientHeight);
    this._rotateUp(_twoPI * this._rotateDelta.y / element.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(event) {
    if (this._pointers.length === 1) {
      this._panEnd.set(event.pageX, event.pageY);
    } else {
      const position = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position.x);
      const y = 0.5 * (event.pageY + position.y);
      this._panEnd.set(x, y);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(event) {
    const position = this._getSecondPointerPosition(event);
    const dx = event.pageX - position.x;
    const dy = event.pageY - position.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    this._dollyEnd.set(0, distance);
    this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed));
    this._dollyOut(this._dollyDelta.y);
    this._dollyStart.copy(this._dollyEnd);
    const centerX = (event.pageX + position.x) * 0.5;
    const centerY = (event.pageY + position.y) * 0.5;
    this._updateZoomParameters(centerX, centerY);
  }
  _handleTouchMoveDollyPan(event) {
    if (this.enableZoom) this._handleTouchMoveDolly(event);
    if (this.enablePan) this._handleTouchMovePan(event);
  }
  _handleTouchMoveDollyRotate(event) {
    if (this.enableZoom) this._handleTouchMoveDolly(event);
    if (this.enableRotate) this._handleTouchMoveRotate(event);
  }
  // pointers
  _addPointer(event) {
    this._pointers.push(event.pointerId);
  }
  _removePointer(event) {
    delete this._pointerPositions[event.pointerId];
    for (let i = 0; i < this._pointers.length; i++) {
      if (this._pointers[i] == event.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
    }
  }
  _isTrackingPointer(event) {
    for (let i = 0; i < this._pointers.length; i++) {
      if (this._pointers[i] == event.pointerId) return true;
    }
    return false;
  }
  _trackPointer(event) {
    let position = this._pointerPositions[event.pointerId];
    if (position === void 0) {
      position = new Vector2();
      this._pointerPositions[event.pointerId] = position;
    }
    position.set(event.pageX, event.pageY);
  }
  _getSecondPointerPosition(event) {
    const pointerId = event.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[pointerId];
  }
  //
  _customWheelEvent(event) {
    const mode = event.deltaMode;
    const newEvent = {
      clientX: event.clientX,
      clientY: event.clientY,
      deltaY: event.deltaY
    };
    switch (mode) {
      case 1:
        newEvent.deltaY *= 16;
        break;
      case 2:
        newEvent.deltaY *= 100;
        break;
    }
    if (event.ctrlKey && !this._controlActive) {
      newEvent.deltaY *= 10;
    }
    return newEvent;
  }
};
function onPointerDown(event) {
  if (this.enabled === false) return;
  if (this._pointers.length === 0) {
    this.domElement.setPointerCapture(event.pointerId);
    this.domElement.addEventListener("pointermove", this._onPointerMove);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  if (this._isTrackingPointer(event)) return;
  this._addPointer(event);
  if (event.pointerType === "touch") {
    this._onTouchStart(event);
  } else {
    this._onMouseDown(event);
  }
}
function onPointerMove(event) {
  if (this.enabled === false) return;
  if (event.pointerType === "touch") {
    this._onTouchMove(event);
  } else {
    this._onMouseMove(event);
  }
}
function onPointerUp(event) {
  this._removePointer(event);
  switch (this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(event.pointerId);
      this.domElement.removeEventListener("pointermove", this._onPointerMove);
      this.domElement.removeEventListener("pointerup", this._onPointerUp);
      this.dispatchEvent(_endEvent);
      this.state = _STATE.NONE;
      break;
    case 1:
      const pointerId = this._pointers[0];
      const position = this._pointerPositions[pointerId];
      this._onTouchStart({ pointerId, pageX: position.x, pageY: position.y });
      break;
  }
}
function onMouseDown(event) {
  let mouseAction;
  switch (event.button) {
    case 0:
      mouseAction = this.mouseButtons.LEFT;
      break;
    case 1:
      mouseAction = this.mouseButtons.MIDDLE;
      break;
    case 2:
      mouseAction = this.mouseButtons.RIGHT;
      break;
    default:
      mouseAction = -1;
  }
  switch (mouseAction) {
    case MOUSE.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseDownDolly(event);
      this.state = _STATE.DOLLY;
      break;
    case MOUSE.ROTATE:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(event);
        this.state = _STATE.PAN;
      } else {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(event);
        this.state = _STATE.ROTATE;
      }
      break;
    case MOUSE.PAN:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(event);
        this.state = _STATE.ROTATE;
      } else {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(event);
        this.state = _STATE.PAN;
      }
      break;
    default:
      this.state = _STATE.NONE;
  }
  if (this.state !== _STATE.NONE) {
    this.dispatchEvent(_startEvent);
  }
}
function onMouseMove(event) {
  switch (this.state) {
    case _STATE.ROTATE:
      if (this.enableRotate === false) return;
      this._handleMouseMoveRotate(event);
      break;
    case _STATE.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseMoveDolly(event);
      break;
    case _STATE.PAN:
      if (this.enablePan === false) return;
      this._handleMouseMovePan(event);
      break;
  }
}
function onMouseWheel(event) {
  if (this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE) return;
  event.preventDefault();
  this.dispatchEvent(_startEvent);
  this._handleMouseWheel(this._customWheelEvent(event));
  this.dispatchEvent(_endEvent);
}
function onKeyDown(event) {
  if (this.enabled === false) return;
  this._handleKeyDown(event);
}
function onTouchStart(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case TOUCH.ROTATE:
          if (this.enableRotate === false) return;
          this._handleTouchStartRotate(event);
          this.state = _STATE.TOUCH_ROTATE;
          break;
        case TOUCH.PAN:
          if (this.enablePan === false) return;
          this._handleTouchStartPan(event);
          this.state = _STATE.TOUCH_PAN;
          break;
        default:
          this.state = _STATE.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case TOUCH.DOLLY_PAN:
          if (this.enableZoom === false && this.enablePan === false) return;
          this._handleTouchStartDollyPan(event);
          this.state = _STATE.TOUCH_DOLLY_PAN;
          break;
        case TOUCH.DOLLY_ROTATE:
          if (this.enableZoom === false && this.enableRotate === false) return;
          this._handleTouchStartDollyRotate(event);
          this.state = _STATE.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = _STATE.NONE;
      }
      break;
    default:
      this.state = _STATE.NONE;
  }
  if (this.state !== _STATE.NONE) {
    this.dispatchEvent(_startEvent);
  }
}
function onTouchMove(event) {
  this._trackPointer(event);
  switch (this.state) {
    case _STATE.TOUCH_ROTATE:
      if (this.enableRotate === false) return;
      this._handleTouchMoveRotate(event);
      this.update();
      break;
    case _STATE.TOUCH_PAN:
      if (this.enablePan === false) return;
      this._handleTouchMovePan(event);
      this.update();
      break;
    case _STATE.TOUCH_DOLLY_PAN:
      if (this.enableZoom === false && this.enablePan === false) return;
      this._handleTouchMoveDollyPan(event);
      this.update();
      break;
    case _STATE.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === false && this.enableRotate === false) return;
      this._handleTouchMoveDollyRotate(event);
      this.update();
      break;
    default:
      this.state = _STATE.NONE;
  }
}
function onContextMenu(event) {
  if (this.enabled === false) return;
  event.preventDefault();
}
function interceptControlDown(event) {
  if (event.key === "Control") {
    this._controlActive = true;
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keyup", this._interceptControlUp, { passive: true, capture: true });
  }
}
function interceptControlUp(event) {
  if (event.key === "Control") {
    this._controlActive = false;
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keyup", this._interceptControlUp, { passive: true, capture: true });
  }
}

// node_modules/urdf-loader/src/URDFClasses.js
var _tempAxis = new Vector3();
var _tempEuler = new Euler();
var _tempTransform = new Matrix4();
var _tempOrigTransform = new Matrix4();
var _tempQuat = new Quaternion();
var _tempScale = new Vector3(1, 1, 1);
var _tempPosition = new Vector3();
var URDFBase = class extends Object3D {
  constructor(...args) {
    super(...args);
    this.urdfNode = null;
    this.urdfName = "";
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.urdfNode = source.urdfNode;
    this.urdfName = source.urdfName;
    return this;
  }
};
var URDFCollider = class extends URDFBase {
  constructor(...args) {
    super(...args);
    this.isURDFCollider = true;
    this.type = "URDFCollider";
  }
};
var URDFVisual = class extends URDFBase {
  constructor(...args) {
    super(...args);
    this.isURDFVisual = true;
    this.type = "URDFVisual";
  }
};
var URDFLink = class extends URDFBase {
  constructor(...args) {
    super(...args);
    this.isURDFLink = true;
    this.type = "URDFLink";
  }
};
var URDFJoint = class extends URDFBase {
  get jointType() {
    return this._jointType;
  }
  set jointType(v) {
    if (this.jointType === v) return;
    this._jointType = v;
    this.matrixWorldNeedsUpdate = true;
    switch (v) {
      case "fixed":
        this.jointValue = [];
        break;
      case "continuous":
      case "revolute":
      case "prismatic":
        this.jointValue = new Array(1).fill(0);
        break;
      case "planar":
        this.jointValue = new Array(3).fill(0);
        this.axis = new Vector3(0, 0, 1);
        break;
      case "floating":
        this.jointValue = new Array(6).fill(0);
        break;
    }
  }
  get angle() {
    return this.jointValue[0];
  }
  constructor(...args) {
    super(...args);
    this.isURDFJoint = true;
    this.type = "URDFJoint";
    this.jointValue = null;
    this.jointType = "fixed";
    this.axis = new Vector3(1, 0, 0);
    this.limit = { lower: 0, upper: 0 };
    this.ignoreLimits = false;
    this.origPosition = null;
    this.origQuaternion = null;
    this.mimicJoints = [];
  }
  /* Overrides */
  copy(source, recursive) {
    super.copy(source, recursive);
    this.jointType = source.jointType;
    this.axis = source.axis.clone();
    this.limit.lower = source.limit.lower;
    this.limit.upper = source.limit.upper;
    this.ignoreLimits = false;
    this.jointValue = [...source.jointValue];
    this.origPosition = source.origPosition ? source.origPosition.clone() : null;
    this.origQuaternion = source.origQuaternion ? source.origQuaternion.clone() : null;
    this.mimicJoints = [...source.mimicJoints];
    return this;
  }
  /* Public Functions */
  /**
   * @param {...number|null} values The joint value components to set, optionally null for no-op
   * @returns {boolean} Whether the invocation of this function resulted in an actual change to the joint value
   */
  setJointValue(...values) {
    values = values.map((v) => v === null ? null : parseFloat(v));
    if (!this.origPosition || !this.origQuaternion) {
      this.origPosition = this.position.clone();
      this.origQuaternion = this.quaternion.clone();
    }
    let didUpdate = false;
    this.mimicJoints.forEach((joint) => {
      didUpdate = joint.updateFromMimickedJoint(...values) || didUpdate;
    });
    switch (this.jointType) {
      case "fixed": {
        return didUpdate;
      }
      case "continuous":
      case "revolute": {
        let angle = values[0];
        if (angle == null) return didUpdate;
        if (angle === this.jointValue[0]) return didUpdate;
        if (!this.ignoreLimits && this.jointType === "revolute") {
          angle = Math.min(this.limit.upper, angle);
          angle = Math.max(this.limit.lower, angle);
        }
        this.quaternion.setFromAxisAngle(this.axis, angle).premultiply(this.origQuaternion);
        if (this.jointValue[0] !== angle) {
          this.jointValue[0] = angle;
          this.matrixWorldNeedsUpdate = true;
          return true;
        } else {
          return didUpdate;
        }
      }
      case "prismatic": {
        let pos = values[0];
        if (pos == null) return didUpdate;
        if (pos === this.jointValue[0]) return didUpdate;
        if (!this.ignoreLimits) {
          pos = Math.min(this.limit.upper, pos);
          pos = Math.max(this.limit.lower, pos);
        }
        this.position.copy(this.origPosition);
        _tempAxis.copy(this.axis).applyEuler(this.rotation);
        this.position.addScaledVector(_tempAxis, pos);
        if (this.jointValue[0] !== pos) {
          this.jointValue[0] = pos;
          this.matrixWorldNeedsUpdate = true;
          return true;
        } else {
          return didUpdate;
        }
      }
      case "floating": {
        if (this.jointValue.every((value, index) => values[index] === value || values[index] === null)) return didUpdate;
        this.jointValue[0] = values[0] !== null ? values[0] : this.jointValue[0];
        this.jointValue[1] = values[1] !== null ? values[1] : this.jointValue[1];
        this.jointValue[2] = values[2] !== null ? values[2] : this.jointValue[2];
        this.jointValue[3] = values[3] !== null ? values[3] : this.jointValue[3];
        this.jointValue[4] = values[4] !== null ? values[4] : this.jointValue[4];
        this.jointValue[5] = values[5] !== null ? values[5] : this.jointValue[5];
        _tempOrigTransform.compose(this.origPosition, this.origQuaternion, _tempScale);
        _tempQuat.setFromEuler(
          _tempEuler.set(
            this.jointValue[3],
            this.jointValue[4],
            this.jointValue[5],
            "XYZ"
          )
        );
        _tempPosition.set(this.jointValue[0], this.jointValue[1], this.jointValue[2]);
        _tempTransform.compose(_tempPosition, _tempQuat, _tempScale);
        _tempOrigTransform.premultiply(_tempTransform);
        this.position.setFromMatrixPosition(_tempOrigTransform);
        this.rotation.setFromRotationMatrix(_tempOrigTransform);
        this.matrixWorldNeedsUpdate = true;
        return true;
      }
      case "planar": {
        if (this.jointValue.every((value, index) => values[index] === value || values[index] === null)) return didUpdate;
        this.jointValue[0] = values[0] !== null ? values[0] : this.jointValue[0];
        this.jointValue[1] = values[1] !== null ? values[1] : this.jointValue[1];
        this.jointValue[2] = values[2] !== null ? values[2] : this.jointValue[2];
        _tempOrigTransform.compose(this.origPosition, this.origQuaternion, _tempScale);
        _tempQuat.setFromAxisAngle(this.axis, this.jointValue[2]);
        _tempPosition.set(this.jointValue[0], this.jointValue[1], 0);
        _tempTransform.compose(_tempPosition, _tempQuat, _tempScale);
        _tempOrigTransform.premultiply(_tempTransform);
        this.position.setFromMatrixPosition(_tempOrigTransform);
        this.rotation.setFromRotationMatrix(_tempOrigTransform);
        this.matrixWorldNeedsUpdate = true;
        return true;
      }
    }
    return didUpdate;
  }
};
var URDFMimicJoint = class extends URDFJoint {
  constructor(...args) {
    super(...args);
    this.type = "URDFMimicJoint";
    this.mimicJoint = null;
    this.offset = 0;
    this.multiplier = 1;
  }
  updateFromMimickedJoint(...values) {
    const modifiedValues = values.map((x) => x * this.multiplier + this.offset);
    return super.setJointValue(...modifiedValues);
  }
  /* Overrides */
  copy(source, recursive) {
    super.copy(source, recursive);
    this.mimicJoint = source.mimicJoint;
    this.offset = source.offset;
    this.multiplier = source.multiplier;
    return this;
  }
};
var URDFRobot = class extends URDFLink {
  constructor(...args) {
    super(...args);
    this.isURDFRobot = true;
    this.urdfNode = null;
    this.urdfRobotNode = null;
    this.robotName = null;
    this.links = null;
    this.joints = null;
    this.colliders = null;
    this.visual = null;
    this.frames = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.urdfRobotNode = source.urdfRobotNode;
    this.robotName = source.robotName;
    this.links = {};
    this.joints = {};
    this.colliders = {};
    this.visual = {};
    this.traverse((c) => {
      if (c.isURDFJoint && c.urdfName in source.joints) {
        this.joints[c.urdfName] = c;
      }
      if (c.isURDFLink && c.urdfName in source.links) {
        this.links[c.urdfName] = c;
      }
      if (c.isURDFCollider && c.urdfName in source.colliders) {
        this.colliders[c.urdfName] = c;
      }
      if (c.isURDFVisual && c.urdfName in source.visual) {
        this.visual[c.urdfName] = c;
      }
    });
    for (const joint in this.joints) {
      this.joints[joint].mimicJoints = this.joints[joint].mimicJoints.map((mimicJoint) => this.joints[mimicJoint.name]);
    }
    this.frames = {
      ...this.colliders,
      ...this.visual,
      ...this.links,
      ...this.joints
    };
    return this;
  }
  getFrame(name) {
    return this.frames[name];
  }
  setJointValue(jointName, ...angle) {
    const joint = this.joints[jointName];
    if (joint) {
      return joint.setJointValue(...angle);
    }
    return false;
  }
  setJointValues(values) {
    let didChange = false;
    for (const name in values) {
      const value = values[name];
      if (Array.isArray(value)) {
        didChange = this.setJointValue(name, ...value) || didChange;
      } else {
        didChange = this.setJointValue(name, value) || didChange;
      }
    }
    return didChange;
  }
};

// node_modules/urdf-loader/src/URDFLoader.js
var tempQuaternion = new Quaternion();
var tempEuler = new Euler();
function processTuple(val) {
  if (!val) return [0, 0, 0];
  return val.trim().split(/\s+/g).map((num) => parseFloat(num));
}
function applyRotation(obj, rpy, additive = false) {
  if (!additive) obj.rotation.set(0, 0, 0);
  tempEuler.set(rpy[0], rpy[1], rpy[2], "ZYX");
  tempQuaternion.setFromEuler(tempEuler);
  tempQuaternion.multiply(obj.quaternion);
  obj.quaternion.copy(tempQuaternion);
}
var URDFLoader = class {
  constructor(manager) {
    this.manager = manager || DefaultLoadingManager;
    this.loadMeshCb = this.defaultMeshLoader.bind(this);
    this.parseVisual = true;
    this.parseCollision = false;
    this.packages = "";
    this.workingPath = "";
    this.fetchOptions = {};
  }
  /* Public API */
  loadAsync(urdf) {
    return new Promise((resolve, reject) => {
      this.load(urdf, resolve, null, reject);
    });
  }
  // urdf:    The path to the URDF within the package OR absolute
  // onComplete:      Callback that is passed the model once loaded
  load(urdf, onComplete, onProgress, onError) {
    const manager = this.manager;
    const workingPath = LoaderUtils.extractUrlBase(urdf);
    const urdfPath = this.manager.resolveURL(urdf);
    manager.itemStart(urdfPath);
    fetch(urdfPath, this.fetchOptions).then((res) => {
      if (res.ok) {
        if (onProgress) {
          onProgress(null);
        }
        return res.text();
      } else {
        throw new Error(`URDFLoader: Failed to load url '${urdfPath}' with error code ${res.status} : ${res.statusText}.`);
      }
    }).then((data) => {
      const model = this.parse(data, this.workingPath || workingPath);
      onComplete(model);
      manager.itemEnd(urdfPath);
    }).catch((e) => {
      if (onError) {
        onError(e);
      } else {
        console.error("URDFLoader: Error loading file.", e);
      }
      manager.itemError(urdfPath);
      manager.itemEnd(urdfPath);
    });
  }
  parse(content, workingPath = this.workingPath) {
    const packages = this.packages;
    const loadMeshCb = this.loadMeshCb;
    const parseVisual = this.parseVisual;
    const parseCollision = this.parseCollision;
    const manager = this.manager;
    const linkMap = {};
    const jointMap = {};
    const materialMap = {};
    function resolvePath(path) {
      if (!/^package:\/\//.test(path)) {
        return workingPath ? workingPath + path : path;
      }
      const [targetPkg, relPath] = path.replace(/^package:\/\//, "").split(/\/(.+)/);
      if (typeof packages === "string") {
        if (packages.endsWith(targetPkg)) {
          return packages + "/" + relPath;
        } else {
          return packages + "/" + targetPkg + "/" + relPath;
        }
      } else if (packages instanceof Function) {
        return packages(targetPkg) + "/" + relPath;
      } else if (typeof packages === "object") {
        if (targetPkg in packages) {
          return packages[targetPkg] + "/" + relPath;
        } else {
          console.error(`URDFLoader : ${targetPkg} not found in provided package list.`);
          return null;
        }
      }
    }
    function processUrdf(data) {
      let children;
      if (data instanceof Document) {
        children = [...data.children];
      } else if (data instanceof Element) {
        children = [data];
      } else {
        const parser = new DOMParser();
        const urdf = parser.parseFromString(data, "text/xml");
        children = [...urdf.children];
      }
      const robotNode = children.filter((c) => c.nodeName === "robot").pop();
      return processRobot(robotNode);
    }
    function processRobot(robot) {
      const robotNodes = [...robot.children];
      const links = robotNodes.filter((c) => c.nodeName.toLowerCase() === "link");
      const joints = robotNodes.filter((c) => c.nodeName.toLowerCase() === "joint");
      const materials = robotNodes.filter((c) => c.nodeName.toLowerCase() === "material");
      const obj = new URDFRobot();
      obj.robotName = robot.getAttribute("name");
      obj.urdfRobotNode = robot;
      materials.forEach((m) => {
        const name = m.getAttribute("name");
        materialMap[name] = processMaterial(m);
      });
      const visualMap = {};
      const colliderMap = {};
      links.forEach((l) => {
        const name = l.getAttribute("name");
        const isRoot = robot.querySelector(`child[link="${name}"]`) === null;
        linkMap[name] = processLink(l, visualMap, colliderMap, isRoot ? obj : null);
      });
      joints.forEach((j) => {
        const name = j.getAttribute("name");
        jointMap[name] = processJoint(j);
      });
      obj.joints = jointMap;
      obj.links = linkMap;
      obj.colliders = colliderMap;
      obj.visual = visualMap;
      const jointList = Object.values(jointMap);
      jointList.forEach((j) => {
        if (j instanceof URDFMimicJoint) {
          jointMap[j.mimicJoint].mimicJoints.push(j);
        }
      });
      jointList.forEach((j) => {
        const uniqueJoints = /* @__PURE__ */ new Set();
        const iterFunction = (joint) => {
          if (uniqueJoints.has(joint)) {
            throw new Error("URDFLoader: Detected an infinite loop of mimic joints.");
          }
          uniqueJoints.add(joint);
          joint.mimicJoints.forEach((j2) => {
            iterFunction(j2);
          });
        };
        iterFunction(j);
      });
      obj.frames = {
        ...colliderMap,
        ...visualMap,
        ...linkMap,
        ...jointMap
      };
      return obj;
    }
    function processJoint(joint) {
      const children = [...joint.children];
      const jointType = joint.getAttribute("type");
      let obj;
      const mimicTag = children.find((n) => n.nodeName.toLowerCase() === "mimic");
      if (mimicTag) {
        obj = new URDFMimicJoint();
        obj.mimicJoint = mimicTag.getAttribute("joint");
        obj.multiplier = parseFloat(mimicTag.getAttribute("multiplier") || 1);
        obj.offset = parseFloat(mimicTag.getAttribute("offset") || 0);
      } else {
        obj = new URDFJoint();
      }
      obj.urdfNode = joint;
      obj.name = joint.getAttribute("name");
      obj.urdfName = obj.name;
      obj.jointType = jointType;
      let parent = null;
      let child = null;
      let xyz = [0, 0, 0];
      let rpy = [0, 0, 0];
      children.forEach((n) => {
        const type = n.nodeName.toLowerCase();
        if (type === "origin") {
          xyz = processTuple(n.getAttribute("xyz"));
          rpy = processTuple(n.getAttribute("rpy"));
        } else if (type === "child") {
          child = linkMap[n.getAttribute("link")];
        } else if (type === "parent") {
          parent = linkMap[n.getAttribute("link")];
        } else if (type === "limit") {
          obj.limit.lower = parseFloat(n.getAttribute("lower") || obj.limit.lower);
          obj.limit.upper = parseFloat(n.getAttribute("upper") || obj.limit.upper);
        }
      });
      parent.add(obj);
      obj.add(child);
      applyRotation(obj, rpy);
      obj.position.set(xyz[0], xyz[1], xyz[2]);
      const axisNode = children.filter((n) => n.nodeName.toLowerCase() === "axis")[0];
      if (axisNode) {
        const axisXYZ = axisNode.getAttribute("xyz").split(/\s+/g).map((num) => parseFloat(num));
        obj.axis = new Vector3(axisXYZ[0], axisXYZ[1], axisXYZ[2]);
        obj.axis.normalize();
      }
      return obj;
    }
    function processLink(link, visualMap, colliderMap, target = null) {
      if (target === null) {
        target = new URDFLink();
      }
      const children = [...link.children];
      target.name = link.getAttribute("name");
      target.urdfName = target.name;
      target.urdfNode = link;
      if (parseVisual) {
        const visualNodes = children.filter((n) => n.nodeName.toLowerCase() === "visual");
        visualNodes.forEach((vn) => {
          const v = processLinkElement(vn, materialMap);
          target.add(v);
          if (vn.hasAttribute("name")) {
            const name = vn.getAttribute("name");
            v.name = name;
            v.urdfName = name;
            visualMap[name] = v;
          }
        });
      }
      if (parseCollision) {
        const collisionNodes = children.filter((n) => n.nodeName.toLowerCase() === "collision");
        collisionNodes.forEach((cn) => {
          const c = processLinkElement(cn);
          target.add(c);
          if (cn.hasAttribute("name")) {
            const name = cn.getAttribute("name");
            c.name = name;
            c.urdfName = name;
            colliderMap[name] = c;
          }
        });
      }
      return target;
    }
    function processMaterial(node) {
      const matNodes = [...node.children];
      const material = new MeshPhongMaterial();
      material.name = node.getAttribute("name") || "";
      matNodes.forEach((n) => {
        const type = n.nodeName.toLowerCase();
        if (type === "color") {
          const rgba = n.getAttribute("rgba").split(/\s/g).map((v) => parseFloat(v));
          material.color.setRGB(rgba[0], rgba[1], rgba[2]);
          material.opacity = rgba[3];
          material.transparent = rgba[3] < 1;
          material.depthWrite = !material.transparent;
        } else if (type === "texture") {
          const filename = n.getAttribute("filename");
          if (filename) {
            const loader = new TextureLoader(manager);
            const filePath = resolvePath(filename);
            material.map = loader.load(filePath);
            material.map.colorSpace = SRGBColorSpace;
          }
        }
      });
      return material;
    }
    function processLinkElement(vn, materialMap2 = {}) {
      const isCollisionNode = vn.nodeName.toLowerCase() === "collision";
      const children = [...vn.children];
      let material = null;
      const materialNode = children.filter((n) => n.nodeName.toLowerCase() === "material")[0];
      if (materialNode) {
        const name = materialNode.getAttribute("name");
        if (name && name in materialMap2) {
          material = materialMap2[name];
        } else {
          material = processMaterial(materialNode);
        }
      } else {
        material = new MeshPhongMaterial();
      }
      const group = isCollisionNode ? new URDFCollider() : new URDFVisual();
      group.urdfNode = vn;
      children.forEach((n) => {
        const type = n.nodeName.toLowerCase();
        if (type === "geometry") {
          const geoType = n.children[0].nodeName.toLowerCase();
          if (geoType === "mesh") {
            const filename = n.children[0].getAttribute("filename");
            const filePath = resolvePath(filename);
            if (filePath !== null) {
              const scaleAttr = n.children[0].getAttribute("scale");
              if (scaleAttr) {
                const scale = processTuple(scaleAttr);
                group.scale.set(scale[0], scale[1], scale[2]);
              }
              loadMeshCb(filePath, manager, (obj, err) => {
                if (err) {
                  console.error("URDFLoader: Error loading mesh.", err);
                } else if (obj) {
                  if (obj instanceof Mesh) {
                    obj.material = material;
                  }
                  obj.position.set(0, 0, 0);
                  obj.quaternion.identity();
                  group.add(obj);
                }
              });
            }
          } else if (geoType === "box") {
            const primitiveModel = new Mesh();
            primitiveModel.geometry = new BoxGeometry(1, 1, 1);
            primitiveModel.material = material;
            const size = processTuple(n.children[0].getAttribute("size"));
            primitiveModel.scale.set(size[0], size[1], size[2]);
            group.add(primitiveModel);
          } else if (geoType === "sphere") {
            const primitiveModel = new Mesh();
            primitiveModel.geometry = new SphereGeometry(1, 30, 30);
            primitiveModel.material = material;
            const radius = parseFloat(n.children[0].getAttribute("radius")) || 0;
            primitiveModel.scale.set(radius, radius, radius);
            group.add(primitiveModel);
          } else if (geoType === "cylinder") {
            const primitiveModel = new Mesh();
            primitiveModel.geometry = new CylinderGeometry(1, 1, 1, 30);
            primitiveModel.material = material;
            const radius = parseFloat(n.children[0].getAttribute("radius")) || 0;
            const length = parseFloat(n.children[0].getAttribute("length")) || 0;
            primitiveModel.scale.set(radius, length, radius);
            primitiveModel.rotation.set(Math.PI / 2, 0, 0);
            group.add(primitiveModel);
          }
        } else if (type === "origin") {
          const xyz = processTuple(n.getAttribute("xyz"));
          const rpy = processTuple(n.getAttribute("rpy"));
          group.position.set(xyz[0], xyz[1], xyz[2]);
          group.rotation.set(0, 0, 0);
          applyRotation(group, rpy);
        }
      });
      return group;
    }
    return processUrdf(content);
  }
  // Default mesh loading function
  defaultMeshLoader(path, manager, done) {
    if (/\.stl$/i.test(path)) {
      const loader = new STLLoader(manager);
      loader.load(path, (geom) => {
        const mesh = new Mesh(geom, new MeshPhongMaterial());
        done(mesh);
      });
    } else if (/\.dae$/i.test(path)) {
      const loader = new ColladaLoader(manager);
      loader.load(path, (dae) => done(dae.scene));
    } else {
      console.warn(`URDFLoader: Could not load model at ${path}.
No loader available`);
    }
  }
};

// node_modules/urdf-loader/src/urdf-viewer-element.js
var tempVec2 = new Vector2();
var emptyRaycast = () => {
};
var URDFViewer = class extends HTMLElement {
  static get observedAttributes() {
    return ["package", "urdf", "up", "display-shadow", "ambient-color", "ignore-limits", "show-collision"];
  }
  get package() {
    return this.getAttribute("package") || "";
  }
  set package(val) {
    this.setAttribute("package", val);
  }
  get urdf() {
    return this.getAttribute("urdf") || "";
  }
  set urdf(val) {
    this.setAttribute("urdf", val);
  }
  get ignoreLimits() {
    return this.hasAttribute("ignore-limits") || false;
  }
  set ignoreLimits(val) {
    val ? this.setAttribute("ignore-limits", val) : this.removeAttribute("ignore-limits");
  }
  get up() {
    return this.getAttribute("up") || "+Z";
  }
  set up(val) {
    this.setAttribute("up", val);
  }
  get displayShadow() {
    return this.hasAttribute("display-shadow") || false;
  }
  set displayShadow(val) {
    val ? this.setAttribute("display-shadow", "") : this.removeAttribute("display-shadow");
  }
  get ambientColor() {
    return this.getAttribute("ambient-color") || "#8ea0a8";
  }
  set ambientColor(val) {
    val ? this.setAttribute("ambient-color", val) : this.removeAttribute("ambient-color");
  }
  get autoRedraw() {
    return this.hasAttribute("auto-redraw") || false;
  }
  set autoRedraw(val) {
    val ? this.setAttribute("auto-redraw", true) : this.removeAttribute("auto-redraw");
  }
  get noAutoRecenter() {
    return this.hasAttribute("no-auto-recenter") || false;
  }
  set noAutoRecenter(val) {
    val ? this.setAttribute("no-auto-recenter", true) : this.removeAttribute("no-auto-recenter");
  }
  get showCollision() {
    return this.hasAttribute("show-collision") || false;
  }
  set showCollision(val) {
    val ? this.setAttribute("show-collision", true) : this.removeAttribute("show-collision");
  }
  get jointValues() {
    const values = {};
    if (this.robot) {
      for (const name in this.robot.joints) {
        const joint = this.robot.joints[name];
        values[name] = joint.jointValue.length === 1 ? joint.angle : [...joint.jointValue];
      }
    }
    return values;
  }
  set jointValues(val) {
    this.setJointValues(val);
  }
  get angles() {
    return this.jointValues;
  }
  set angles(v) {
    this.jointValues = v;
  }
  /* Lifecycle Functions */
  constructor() {
    super();
    this._requestId = 0;
    this._dirty = false;
    this._loadScheduled = false;
    this.robot = null;
    this.loadMeshFunc = null;
    this.urlModifierFunc = null;
    const scene = new Scene();
    const ambientLight = new HemisphereLight(this.ambientColor, "#000");
    ambientLight.groundColor.lerp(ambientLight.color, 0.5 * Math.PI);
    ambientLight.intensity = 0.5;
    ambientLight.position.set(0, 1, 0);
    scene.add(ambientLight);
    const dirLight = new DirectionalLight(16777215, Math.PI);
    dirLight.position.set(4, 10, 1);
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.normalBias = 1e-3;
    dirLight.castShadow = true;
    scene.add(dirLight);
    scene.add(dirLight.target);
    const renderer = new WebGLRenderer({ antialias: true, alpha: true });
    renderer.setClearColor(16777215);
    renderer.setClearAlpha(0);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = PCFSoftShadowMap;
    renderer.outputColorSpace = SRGBColorSpace;
    const camera = new PerspectiveCamera(75, 1, 0.1, 1e3);
    camera.position.z = -10;
    const world = new Object3D();
    scene.add(world);
    const plane2 = new Mesh(
      new PlaneGeometry(40, 40),
      new ShadowMaterial({ side: DoubleSide, transparent: true, opacity: 0.25 })
    );
    plane2.rotation.x = -Math.PI / 2;
    plane2.position.y = -0.5;
    plane2.receiveShadow = true;
    plane2.scale.set(10, 10, 10);
    scene.add(plane2);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.rotateSpeed = 2;
    controls.zoomSpeed = 5;
    controls.panSpeed = 2;
    controls.enableZoom = true;
    controls.enableDamping = false;
    controls.maxDistance = 50;
    controls.minDistance = 0.25;
    controls.addEventListener("change", () => this.recenter());
    this.scene = scene;
    this.world = world;
    this.renderer = renderer;
    this.camera = camera;
    this.controls = controls;
    this.plane = plane2;
    this.directionalLight = dirLight;
    this.ambientLight = ambientLight;
    this._setUp(this.up);
    this._collisionMaterial = new MeshPhongMaterial({
      transparent: true,
      opacity: 0.35,
      shininess: 2.5,
      premultipliedAlpha: true,
      color: 16760376,
      polygonOffset: true,
      polygonOffsetFactor: -1,
      polygonOffsetUnits: -1
    });
    const _renderLoop = () => {
      if (this.parentNode) {
        this.updateSize();
        if (this._dirty || this.autoRedraw) {
          if (!this.noAutoRecenter) {
            this._updateEnvironment();
          }
          this.renderer.render(scene, camera);
          this._dirty = false;
        }
        this.controls.update();
      }
      this._renderLoopId = requestAnimationFrame(_renderLoop);
    };
    _renderLoop();
  }
  connectedCallback() {
    if (!this.constructor._styletag) {
      const styletag = document.createElement("style");
      styletag.innerHTML = `
                ${this.tagName} { display: block; }
                ${this.tagName} canvas {
                    width: 100%;
                    height: 100%;
                }
            `;
      document.head.appendChild(styletag);
      this.constructor._styletag = styletag;
    }
    if (this.childElementCount === 0) {
      this.appendChild(this.renderer.domElement);
    }
    this.updateSize();
    requestAnimationFrame(() => this.updateSize());
  }
  disconnectedCallback() {
    cancelAnimationFrame(this._renderLoopId);
  }
  attributeChangedCallback(attr, oldval, newval) {
    this._updateCollisionVisibility();
    if (!this.noAutoRecenter) {
      this.recenter();
    }
    switch (attr) {
      case "package":
      case "urdf": {
        this._scheduleLoad();
        break;
      }
      case "up": {
        this._setUp(this.up);
        break;
      }
      case "ambient-color": {
        this.ambientLight.color.set(this.ambientColor);
        this.ambientLight.groundColor.set("#000").lerp(this.ambientLight.color, 0.5);
        break;
      }
      case "ignore-limits": {
        this._setIgnoreLimits(this.ignoreLimits, true);
        break;
      }
    }
  }
  /* Public API */
  updateSize() {
    const r = this.renderer;
    const w = this.clientWidth;
    const h = this.clientHeight;
    const currSize = r.getSize(tempVec2);
    if (currSize.width !== w || currSize.height !== h) {
      this.recenter();
    }
    r.setPixelRatio(window.devicePixelRatio);
    r.setSize(w, h, false);
    this.camera.aspect = w / h;
    this.camera.updateProjectionMatrix();
  }
  redraw() {
    this._dirty = true;
  }
  recenter() {
    this._updateEnvironment();
    this.redraw();
  }
  // Set the joint with jointName to
  // angle in degrees
  setJointValue(jointName, ...values) {
    if (!this.robot) return;
    if (!this.robot.joints[jointName]) return;
    if (this.robot.joints[jointName].setJointValue(...values)) {
      this.redraw();
      this.dispatchEvent(new CustomEvent("angle-change", { bubbles: true, cancelable: true, detail: jointName }));
    }
  }
  setJointValues(values) {
    for (const name in values) this.setJointValue(name, values[name]);
  }
  /* Private Functions */
  // Updates the position of the plane to be at the
  // lowest point below the robot and focuses the
  // camera on the center of the scene
  _updateEnvironment() {
    const robot = this.robot;
    if (!robot) return;
    this.world.updateMatrixWorld();
    const bbox = new Box3();
    bbox.makeEmpty();
    robot.traverse((c) => {
      if (c.isURDFVisual) {
        bbox.expandByObject(c);
      }
    });
    const center = bbox.getCenter(new Vector3());
    this.controls.target.y = center.y;
    this.plane.position.y = bbox.min.y - 1e-3;
    const dirLight = this.directionalLight;
    dirLight.castShadow = this.displayShadow;
    if (this.displayShadow) {
      const sphere = bbox.getBoundingSphere(new Sphere());
      const minmax = sphere.radius;
      const cam = dirLight.shadow.camera;
      cam.left = cam.bottom = -minmax;
      cam.right = cam.top = minmax;
      const offset = dirLight.position.clone().sub(dirLight.target.position);
      dirLight.target.position.copy(center);
      dirLight.position.copy(center).add(offset);
      cam.updateProjectionMatrix();
    }
  }
  _scheduleLoad() {
    if (this._prevload === `${this.package}|${this.urdf}`) return;
    this._prevload = `${this.package}|${this.urdf}`;
    if (this._loadScheduled) return;
    this._loadScheduled = true;
    if (this.robot) {
      this.robot.traverse((c) => c.dispose && c.dispose());
      this.robot.parent.remove(this.robot);
      this.robot = null;
    }
    requestAnimationFrame(() => {
      this._loadUrdf(this.package, this.urdf);
      this._loadScheduled = false;
    });
  }
  // Watch the package and urdf field and load the robot model.
  // This should _only_ be called from _scheduleLoad because that
  // ensures the that current robot has been removed
  _loadUrdf(pkg, urdf) {
    this.dispatchEvent(new CustomEvent("urdf-change", { bubbles: true, cancelable: true, composed: true }));
    if (urdf) {
      this._requestId++;
      const requestId = this._requestId;
      const updateMaterials = (mesh) => {
        mesh.traverse((c) => {
          if (c.isMesh) {
            c.castShadow = true;
            c.receiveShadow = true;
            if (c.material) {
              const mats = (Array.isArray(c.material) ? c.material : [c.material]).map((m) => {
                if (m instanceof MeshBasicMaterial) {
                  m = new MeshPhongMaterial();
                }
                if (m.map) {
                  m.map.colorSpace = SRGBColorSpace;
                }
                return m;
              });
              c.material = mats.length === 1 ? mats[0] : mats;
            }
          }
        });
      };
      if (pkg.includes(":") && pkg.split(":")[1].substring(0, 2) !== "//") {
        pkg = pkg.split(",").reduce((map, value) => {
          const split = value.split(/:/).filter((x) => !!x);
          const pkgName = split.shift().trim();
          const pkgPath = split.join(":").trim();
          map[pkgName] = pkgPath;
          return map;
        }, {});
      }
      let robot = null;
      const manager = new LoadingManager();
      manager.onLoad = () => {
        if (this._requestId !== requestId) {
          robot.traverse((c) => c.dispose && c.dispose());
          return;
        }
        this.robot = robot;
        this.world.add(robot);
        updateMaterials(robot);
        this._setIgnoreLimits(this.ignoreLimits);
        this._updateCollisionVisibility();
        this.dispatchEvent(new CustomEvent("urdf-processed", { bubbles: true, cancelable: true, composed: true }));
        this.dispatchEvent(new CustomEvent("geometry-loaded", { bubbles: true, cancelable: true, composed: true }));
        this.recenter();
      };
      if (this.urlModifierFunc) {
        manager.setURLModifier(this.urlModifierFunc);
      }
      const loader = new URDFLoader(manager);
      loader.packages = pkg;
      loader.loadMeshCb = this.loadMeshFunc;
      loader.fetchOptions = { mode: "cors", credentials: "same-origin" };
      loader.parseCollision = true;
      loader.load(urdf, (model) => robot = model);
    }
  }
  _updateCollisionVisibility() {
    const showCollision = this.showCollision;
    const collisionMaterial = this._collisionMaterial;
    const robot = this.robot;
    if (robot === null) return;
    const colliders = [];
    robot.traverse((c) => {
      if (c.isURDFCollider) {
        c.visible = showCollision;
        colliders.push(c);
      }
    });
    colliders.forEach((coll) => {
      coll.traverse((c) => {
        if (c.isMesh) {
          c.raycast = emptyRaycast;
          c.material = collisionMaterial;
          c.castShadow = false;
        }
      });
    });
  }
  // Watch the coordinate frame and update the
  // rotation of the scene to match
  _setUp(up) {
    if (!up) up = "+Z";
    up = up.toUpperCase();
    const sign = up.replace(/[^-+]/g, "")[0] || "+";
    const axis = up.replace(/[^XYZ]/gi, "")[0] || "Z";
    const PI = Math.PI;
    const HALFPI = PI / 2;
    if (axis === "X") this.world.rotation.set(0, 0, sign === "+" ? HALFPI : -HALFPI);
    if (axis === "Z") this.world.rotation.set(sign === "+" ? -HALFPI : HALFPI, 0, 0);
    if (axis === "Y") this.world.rotation.set(sign === "+" ? 0 : PI, 0, 0);
  }
  // Updates the current robot's angles to ignore
  // joint limits or not
  _setIgnoreLimits(ignore, dispatch = false) {
    if (this.robot) {
      Object.values(this.robot.joints).forEach((joint) => {
        joint.ignoreLimits = ignore;
        joint.setJointValue(...joint.jointValue);
      });
    }
    if (dispatch) {
      this.dispatchEvent(new CustomEvent("ignore-limits-change", { bubbles: true, cancelable: true, composed: true }));
    }
  }
};

// node_modules/urdf-loader/src/URDFDragControls.js
function isJoint(j) {
  return j.isURDFJoint && j.jointType !== "fixed";
}
function findNearestJoint(child) {
  let curr = child;
  while (curr) {
    if (isJoint(curr)) {
      return curr;
    }
    curr = curr.parent;
  }
  return curr;
}
var prevHitPoint = new Vector3();
var newHitPoint = new Vector3();
var pivotPoint = new Vector3();
var tempVector = new Vector3();
var tempVector2 = new Vector3();
var projectedStartPoint = new Vector3();
var projectedEndPoint = new Vector3();
var plane = new Plane();
var URDFDragControls = class {
  constructor(scene) {
    this.enabled = true;
    this.scene = scene;
    this.raycaster = new Raycaster();
    this.initialGrabPoint = new Vector3();
    this.hitDistance = -1;
    this.hovered = null;
    this.manipulating = null;
  }
  update() {
    const {
      raycaster,
      hovered,
      manipulating,
      scene
    } = this;
    if (manipulating) {
      return;
    }
    let hoveredJoint = null;
    const intersections = raycaster.intersectObject(scene, true);
    if (intersections.length !== 0) {
      const hit = intersections[0];
      this.hitDistance = hit.distance;
      hoveredJoint = findNearestJoint(hit.object);
      this.initialGrabPoint.copy(hit.point);
    }
    if (hoveredJoint !== hovered) {
      if (hovered) {
        this.onUnhover(hovered);
      }
      this.hovered = hoveredJoint;
      if (hoveredJoint) {
        this.onHover(hoveredJoint);
      }
    }
  }
  updateJoint(joint, angle) {
    joint.setJointValue(angle);
  }
  onDragStart(joint) {
  }
  onDragEnd(joint) {
  }
  onHover(joint) {
  }
  onUnhover(joint) {
  }
  getRevoluteDelta(joint, startPoint, endPoint) {
    tempVector.copy(joint.axis).transformDirection(joint.matrixWorld).normalize();
    pivotPoint.set(0, 0, 0).applyMatrix4(joint.matrixWorld);
    plane.setFromNormalAndCoplanarPoint(tempVector, pivotPoint);
    plane.projectPoint(startPoint, projectedStartPoint);
    plane.projectPoint(endPoint, projectedEndPoint);
    projectedStartPoint.sub(pivotPoint);
    projectedEndPoint.sub(pivotPoint);
    tempVector.crossVectors(projectedStartPoint, projectedEndPoint);
    const direction = Math.sign(tempVector.dot(plane.normal));
    return direction * projectedEndPoint.angleTo(projectedStartPoint);
  }
  getPrismaticDelta(joint, startPoint, endPoint) {
    tempVector.subVectors(endPoint, startPoint);
    plane.normal.copy(joint.axis).transformDirection(joint.parent.matrixWorld).normalize();
    return tempVector.dot(plane.normal);
  }
  moveRay(toRay) {
    const { raycaster, hitDistance, manipulating } = this;
    const { ray } = raycaster;
    if (manipulating) {
      ray.at(hitDistance, prevHitPoint);
      toRay.at(hitDistance, newHitPoint);
      let delta = 0;
      if (manipulating.jointType === "revolute" || manipulating.jointType === "continuous") {
        delta = this.getRevoluteDelta(manipulating, prevHitPoint, newHitPoint);
      } else if (manipulating.jointType === "prismatic") {
        delta = this.getPrismaticDelta(manipulating, prevHitPoint, newHitPoint);
      }
      if (delta) {
        this.updateJoint(manipulating, manipulating.angle + delta);
      }
    }
    this.raycaster.ray.copy(toRay);
    this.update();
  }
  setGrabbed(grabbed) {
    const { hovered, manipulating } = this;
    if (grabbed) {
      if (manipulating !== null || hovered === null) {
        return;
      }
      this.manipulating = hovered;
      this.onDragStart(hovered);
    } else {
      if (this.manipulating === null) {
        return;
      }
      this.onDragEnd(this.manipulating);
      this.manipulating = null;
      this.update();
    }
  }
};
var PointerURDFDragControls = class extends URDFDragControls {
  constructor(scene, camera, domElement) {
    super(scene);
    this.camera = camera;
    this.domElement = domElement;
    const raycaster = new Raycaster();
    const mouse = new Vector2();
    function updateMouse(e) {
      const rect = domElement.getBoundingClientRect();
      mouse.x = (e.clientX - rect.left) / rect.width * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    }
    this._mouseDown = (e) => {
      updateMouse(e);
      raycaster.setFromCamera(mouse, this.camera);
      this.moveRay(raycaster.ray);
      this.setGrabbed(true);
    };
    this._mouseMove = (e) => {
      updateMouse(e);
      raycaster.setFromCamera(mouse, this.camera);
      this.moveRay(raycaster.ray);
    };
    this._mouseUp = (e) => {
      updateMouse(e);
      raycaster.setFromCamera(mouse, this.camera);
      this.moveRay(raycaster.ray);
      this.setGrabbed(false);
    };
    domElement.addEventListener("mousedown", this._mouseDown);
    domElement.addEventListener("mousemove", this._mouseMove);
    domElement.addEventListener("mouseup", this._mouseUp);
  }
  getRevoluteDelta(joint, startPoint, endPoint) {
    const { camera, initialGrabPoint } = this;
    tempVector.copy(joint.axis).transformDirection(joint.matrixWorld).normalize();
    pivotPoint.set(0, 0, 0).applyMatrix4(joint.matrixWorld);
    plane.setFromNormalAndCoplanarPoint(tempVector, pivotPoint);
    tempVector.copy(camera.position).sub(initialGrabPoint).normalize();
    if (Math.abs(tempVector.dot(plane.normal)) > 0.3) {
      return super.getRevoluteDelta(joint, startPoint, endPoint);
    } else {
      tempVector.set(0, 1, 0).transformDirection(camera.matrixWorld);
      plane.projectPoint(startPoint, projectedStartPoint);
      plane.projectPoint(endPoint, projectedEndPoint);
      tempVector.set(0, 0, -1).transformDirection(camera.matrixWorld);
      tempVector.cross(plane.normal);
      tempVector2.subVectors(endPoint, startPoint);
      return tempVector.dot(tempVector2);
    }
  }
  dispose() {
    const { domElement } = this;
    domElement.removeEventListener("mousedown", this._mouseDown);
    domElement.removeEventListener("mousemove", this._mouseMove);
    domElement.removeEventListener("mouseup", this._mouseUp);
  }
};

// node_modules/urdf-loader/src/urdf-manipulator-element.js
var URDFManipulator = class extends URDFViewer {
  static get observedAttributes() {
    return ["highlight-color", ...super.observedAttributes];
  }
  get disableDragging() {
    return this.hasAttribute("disable-dragging");
  }
  set disableDragging(val) {
    val ? this.setAttribute("disable-dragging", !!val) : this.removeAttribute("disable-dragging");
  }
  get highlightColor() {
    return this.getAttribute("highlight-color") || "#FFFFFF";
  }
  set highlightColor(val) {
    val ? this.setAttribute("highlight-color", val) : this.removeAttribute("highlight-color");
  }
  constructor(...args) {
    super(...args);
    this.highlightMaterial = new MeshPhongMaterial({
      shininess: 10,
      color: this.highlightColor,
      emissive: this.highlightColor,
      emissiveIntensity: 0.25
    });
    const isJoint2 = (j) => {
      return j.isURDFJoint && j.jointType !== "fixed";
    };
    const highlightLinkGeometry = (m, revert) => {
      const traverse = (c) => {
        if (c.type === "Mesh") {
          if (revert) {
            c.material = c.__origMaterial;
            delete c.__origMaterial;
          } else {
            c.__origMaterial = c.material;
            c.material = this.highlightMaterial;
          }
        }
        if (c === m || !isJoint2(c)) {
          for (let i = 0; i < c.children.length; i++) {
            const child = c.children[i];
            if (!child.isURDFCollider) {
              traverse(c.children[i]);
            }
          }
        }
      };
      traverse(m);
    };
    const el = this.renderer.domElement;
    const dragControls = new PointerURDFDragControls(this.scene, this.camera, el);
    dragControls.onDragStart = (joint) => {
      this.dispatchEvent(new CustomEvent("manipulate-start", { bubbles: true, cancelable: true, detail: joint.name }));
      this.controls.enabled = false;
      this.redraw();
    };
    dragControls.onDragEnd = (joint) => {
      this.dispatchEvent(new CustomEvent("manipulate-end", { bubbles: true, cancelable: true, detail: joint.name }));
      this.controls.enabled = true;
      this.redraw();
    };
    dragControls.updateJoint = (joint, angle) => {
      this.setJointValue(joint.name, angle);
    };
    dragControls.onHover = (joint) => {
      highlightLinkGeometry(joint, false);
      this.dispatchEvent(new CustomEvent("joint-mouseover", { bubbles: true, cancelable: true, detail: joint.name }));
      this.redraw();
    };
    dragControls.onUnhover = (joint) => {
      highlightLinkGeometry(joint, true);
      this.dispatchEvent(new CustomEvent("joint-mouseout", { bubbles: true, cancelable: true, detail: joint.name }));
      this.redraw();
    };
    this.dragControls = dragControls;
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.dragControls.dispose();
  }
  attributeChangedCallback(attr, oldval, newval) {
    super.attributeChangedCallback(attr, oldval, newval);
    switch (attr) {
      case "highlight-color":
        this.highlightMaterial.color.set(this.highlightColor);
        this.highlightMaterial.emissive.set(this.highlightColor);
        break;
    }
  }
};
export {
  URDFManipulator as default
};
//# sourceMappingURL=urdf-loader_src_urdf-manipulator-element__js.js.map
